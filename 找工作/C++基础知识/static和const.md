## <center>static和const</center>



###  static

#### 1、static的两个作用

**一、控制存储方式**

使用static之后变量将存储在静态存储区而不是像局部变量一样存储在栈空间。这样的一种场景就是：一个函数中我想定义一个变量，每次调用的时候我都希望它保存之前的结果，而不是每次都重新声明使用。可能我们想实现这个功能就会想到全局变量，但是使用全局变量会有一个缺点：本来这个变量我只想在函数中使用，现在你把它变成了全局可使用了。这个时候使用static就完美的解决了问题。

```C++
int test_static() {
	static int count = 0;
	++count;
	return count;
}

int main()
{
	int count = 0;
	for (int i = 0; i < 10; ++i) {
		cout << test_static() << " ";
	}
    cout<<endl;
    cout<<count<<endl;
    return 0;
}
```

输出结果：

```C++
1 2 3 4 5 6 7 8 9 10
0
```

**二、控制可见性和连接类型**

可见性其实上面例子已经说明了，连接类型现在会变成[内部连接](https://www.cnblogs.com/suiyu/archive/2011/11/24/2262116.html)（只在本编译单元中可见）。



#### 2、类中的static成员

**出现的作用**：

1) 需要在一个类的各个对象之间交互，也就是说使用一个数据对象而不是单个对象服务.

2) 同时又没有破坏类的封装性，即要求此成员隐藏在类的内部，对外不可见。

**注意**：

1）对于静态的数据成员，连接器会保证它拥有一个单一的外部定义。静态数据成员按定义出现的先后顺序依次初始化，注意静态成员嵌套的成员已经初始化了。消除时的顺序是初始化的反顺序。

2）类的静态成员函数是属于整个类而非对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数。

### const

#### 1、为什么引入const

c++预处理指令可以很方便的进行值替代

```C++
#define USER_NUM_MAX 107
```

但是预处理语句仅仅是简单的替代，缺乏类型的检查机制，这样预处理语句就不能享受C++严格类型检查的好处，从而可能引发一系列的错误隐患。

所以const推出的最初目的就是为了取代预处理编译指令，消除它的确定继承它的优点。

#### 2、为什么const能取代预处理编译指令

1）const修饰的常量值，具有不可变性，这是它能取代预定义语句的基础。

2）可以很方便的对参数进行修改和调整；

3）编译器不为普通的const常量分配存储空间，而是将他们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高，同时这也是它取代预定义语句的基础。

4）const定义也像一个普通的变量定义一样，它会有编译器对它进行类型的检测，消除预定义语句的隐患。

#### 3、const使用情况分析

1）const用于指针的两种情况

```C++
int const*A; //A可变， *A不可变，常量指针：指向常量的指针
int *const A = &i;//A不可变，*A可变,指针常量：指针是常量
```

2）const 限定函数的传递值参数

```C++
void Fun(const int var);//参数在函数体内不可变，但是实际变不变不会影响外部值
//所以最好改为
void Fun(int var){
    const int& ref_var = var;
}
```

3) const限制函数的返回值

```C++
const int Fun1();//返回值不可更新，对于内部类型多余
const Myclass Fun2();//返回值不可更新，里面的成员变量还是可以修改。。。
```

4）传递与返回地址

5）const限定类的成员函数

```C++
class foo{
public:
    int fun() const;//可以操作常量对象，但是不能修改成员变量，this指针变成了const的
}
```

### inline

#### 1、为什么要引入inline

与const类似的，为了替代c中表达式形式的宏定义。

```C++
#define EXPRESION(var1,var2) (var1+var2)*(var1-var2)
```

那为什么要替换这种呢？

1）C++中引入了类，上面这种形式无法访问设置了访问限制的变量；

2）不能进行参数的有效性检测。

#### 2、inline函数的处理

1）inline函数定义的类的内联函数，函数的代码放在符号表中，在使用时直接进行替换，没有调用开销，效率也很高。

2）很明显，类的内联函数也还是一个真正的函数，编译器在调用一个内联函数是，会首先检查他的参数的类型，保证调用正确性。然后进行一系列相关检查，就像对待任何一个真正的函数一样。

3）inline函数作为某个类的成员函数，当然就可以在其中使用类的保护成员以及私有成员。

#### 3、在何时使用inline函数

inline函数一般只会在函数内容十分简单的时候。如果函数太复杂，代码膨胀带来的恶果可能会大于效率的提高带来的益处。

1）在类中定义

```C++
class className{
    int getWidth(){return this.width;}//直接在类中定义可以不使用inline
}
```

2）在类中声明，在类外定义

```C++
class className{
    int getWidth();
}
inline int className::getWidth(){
    return this.width;
}
```





