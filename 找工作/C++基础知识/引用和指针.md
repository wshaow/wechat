## <center>引用和指针</center>

#### 1、区别

本质：引用是别名，指针是地址。

1、指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定之后就不在改变。

2、从内存分配上来看，程序为指针变量分配内存区域，而不为引用分配内存区域。引用不能指向空值。

3、从编译上看，程序编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名以及变量所对应的地址。指针变量在符号表上对应的地址为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以修改），而引用不能。这是使指针不安全而引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针（指针常量）。

4、不存在指向空值的引用这个事实，意味着使用引用的代码效率要比使用指针的要高。因为在使用引用前不需要测试它的合法性，相反，指针则应该总是被测试，以防止其为空。

5、理论上对指针的级数没有限制但是对引用的只能一级。

#### 2、常量指针和常量引用

1、**常量指针**：指向常量的指针, 不能通过指针符改变对应变量的值。也是不能有`*p=88`这种出现

```C++
const int* const_pointer = &i;
```

2、**常量引用**：指向常量的引用。不能通过引用改变之前的变量的值。也就是不能出现`ref=88`这种出现。

```C++
const int & ref = i;
```

#### 3、指针常量和引用常量

1、**指针常量**：指针是常量。也就是指针本身是常量，因此不能出现这种`p = &i`,这种重新对指针赋值。且在定义时必须初始化。

```C++
int* const pointer = &i;
```

2、实际上引用本身就是常量，定义的时候就需要初始化，之后不能再重新绑定引用到其他变量。

#### 4、指针传递和引用传递

1、**指针传递**：指针传递本质上是指传递的方式，只不过传递的是一个地址值。值传递的过程中，被调函数的形参作为被调函数的局部变量处理，即在栈中开辟了内存空间来存放有主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量值。

2、**引用传递**：被调函数的形式参数作为局部变量咋栈中开辟了内存空间，但是这时存放的是有主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成了间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参的任何操作都影响了主调函数实参变量。

3、**区别**：引用传递会直接传递到外部对应的变量上，但是指针传递它其实并不能改变指针的值，只能改变指针指向的地址的值。如果想改变指针的值需要使用指向指针的指针作为参数类型，或者使用指针的引用类型。

#### 5、总结

**相同点**：

1.都是地址的概念

2.指针指向一块内存，它的值是所值向内存的地址；而引用是某块内存的别名。

**不同点**：

1.指针是一个实体，而引用仅是一个别名。

2.引用只能在被定义时初始化一次，之后不可变；指针是可变的。

3.引用不能为空，指针可以为空；

4.sizeof引用得到的是所指向的对象的大小，sizeof指针得到的是指针本身的大小。

5.指针和引用的自增运算意义不一样。

6.引用是类型安全的，而指针不是。（什么叫类型安全？不能强制转换？）



