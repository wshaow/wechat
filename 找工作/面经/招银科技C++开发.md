## 招银面经一

#### 1、自我介绍两分钟

#### 2、C++的内存管理方式

分为5个存储区：

**栈**：局部变量，函数参数等存储在该区。由编译器自动分配和释放。栈属于计算机系统的数据结构，进栈和出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率十分高，内存空间是连续的，但是空间十分有限。

**堆**：需要程序员手动分配和释放，属于动态分配方式。内存空间几乎没有限制内存空间可以不连续，因此会产生内存碎片。操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序并将该节点从链表中删除。一般系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该内存空间。

**全局/静态存储区**：全局变量，静态变量分配到该区，到程序结束时自动释放，包括DATA段（全局初始化区）与BBS段（全局未初始化段）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BBS段。BBS段特点：在程序执行前BBS段自动清零，所以未初始化的全局变量和静态变量在执行前已经成为0.

**文字常量区**：存放常量，而且不允许修改。程序结束后由系统释放。

**程序代码区**：存放程序的二进制代码。

#### 3、堆和栈的区别

**空间大小**：栈的空间是连续的，空间大小通常是系统预先规定好的，即栈顶地址和最大空间是确定的，而堆的内存空间是不连续的，由一个记录空间的链表负责，因此内存空间基本没有限制。

**管理方式**：栈由编译器自动分配和释放，堆需要程序员手动分配和释放，若忘记delete，容易产生内存泄漏。

**生长方式不同**：对于栈，是向着内存地址减小的方向生长的，这也是为什么栈的内存空间是有限的；而堆是向着内存地址增大的方向生长的。

**碎片问题**：由于栈的内存空间是连续的，先进后出的方式不会产生零碎的空间；而堆分配方式是每次在空闲链表中遍历到第一个大于申请空间的节点，每次分配的空间大小一般不会正好等于申请的内存大小，频繁的new操作势必会产生大量空间碎片。

**分配效率**：栈属于机器系统提供的数据结构，计算机会在底层对栈提供支持，出栈入栈由专门的指令执行，因此效率比较高。而堆是C/C++函数库提供的，当申请空间时需要按照一定的算法搜索足够大小的内存空间，当没有足够的空间时，还需要额外的处理，因此效率较低。

#### 4、new和malloc区别

**属性**：new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。

**参数**：使用new操作符申请内存分配是无需指定块的大小，编译器会根据类型信息自行进行计算。而malloc则需要显式的指定所需内存的尺寸。

**返回类型**：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类安全性的操作符。而malloc内存分配成功则是返回void*，需要通过强制类型转换将void *转换成我们需要的类型。

**分配失败**：new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。

**自定义类型**：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

**重载**：C++允许重载new/delete操作符。malloc不允许重载。

**内存区域**：

new操作符从自由存储区上为对象分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于对，布局new就可以不位于堆中。

#### 5、线程、进程、协程

**进程**：进程是一个程序执行实例，每一个进程提供执行程序所需的所有资源。（进程本质上就是资源的集合）进程拥有自己独立的堆和栈，堆和栈都不共享，有操作系统进行调度。

**线程**：操作系统能够进行运算调度的最小单位。它包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程可以并发多个线程，每个线程并行执行不同的任务。线程拥有自己独立的栈，但是堆是共享的，标准的线程也是由操作系统调度的。

**协程**：协程是一种用户态的轻量级线程。协程的调度时由用户控制，拥有自己独立的寄存器上下文，协程的切换效率比线程还高。

**协程和线程的区别**：1）线程是由CPU调度，而协程是由用户调度；2）线程存在安全问题，协程比线程较安全；3）线程使用同步机制，协程使用异步机制。

**管程**：管程实际上是定义的一种数据结构和控制进程的一些操作的集合。

