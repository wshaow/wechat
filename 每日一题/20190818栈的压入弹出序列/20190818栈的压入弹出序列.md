---

title: 2019-8-18 栈的压入弹出序列

tags: 算法,每日一题,栈

---

## <center> 栈的压入弹出序列 </center>

### 1. 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

### 2. 题目解析

题目的意思是假如我现在要将1,2,3,4,5依次压入栈中，但是在压入的过程中我可以弹出栈中的元素。例如：现在栈中有1,2,3三个元素，在压入4之前我们先将3弹出那么弹出序列中的第一个元素就是3.这个地方其实衍生出了另外一道题，就是给定一个入栈顺序，求所有可能的出栈顺序数。这个的结论是一个卡特兰数 $f(n) = C(2n,n)/(n+1)$.

#### 2.1 解题思路

首先入栈顺序是知道的，因此借助一个辅助栈一个一个将入栈序列压入栈，每次压入一个数，都比较辅助栈顶的元素是否和出栈序列中的第一个元素相同，如果相同说明这时从栈中弹出了一个数据。那么弹出序列向后移动一个。重复这个过程直到遍历完整个压入序列。最后如果辅助栈为空说明压入序列与弹出序列匹配。

``` C++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        //入参判断
        if(pushV.empty() || pushV.size() != popV.size()) return false;
        
        stack<int> help_stack;//辅助栈
        //遍历压入序列
        for(int i=0, j=0; i<pushV.size(); ){
            help_stack.push(pushV[i++]);
            //如果当前辅助栈顶元素与弹出栈相同，辅助栈弹出一个，弹出序列后移
            while( !help_stack.empty() && j < popV.size() && help_stack.top() == popV[j]){
                help_stack.pop();
                ++j;
            }
        }
        return help_stack.empty();
    }
};
```

更多关于编程和机器学习资料请关注FlyAI公众号。
![公众号二维码][1]

  [1]: http://pwfic6399.bkt.clouddn.com/wechat/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg



